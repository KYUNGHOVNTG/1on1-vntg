# 🔐 로그인 및 인증 프로세스 가이드

이 문서는 프로젝트의 로그인 플로우, Google OAuth 연동, 그리고 인증 토큰 관리 방식을 설명합니다.

---

## 🚀 1. 로그인 전체 플로우

사용자가 서비스에 접속하여 로그인을 완료하기까지의 과정은 다음과 같습니다.

### 1단계: Google 인증 요청
1. 클라이언트가 `/api/v1/auth/google/url`을 호출하여 Google 인증 URL을 가져옵니다.
2. 사용자가 Google 로그인 화면에서 인증을 수행합니다.

### 2단계: 콜백 처리 및 세션 충돌 확인
1. 인증 성공 후 Google은 클라이언트로 `authorization code`를 전달합니다.
2. 클라이언트는 `/api/v1/auth/google/callback` 엔드포인트로 코드를 전송합니다.
3. **백엔드 검증**:
   - Google API를 통해 사용자 정보(Email 등)를 가져옵니다.
   - DB에서 해당 사용자의 **활성 세션**이 있는지 확인합니다.
   - **활성 세션이 없을 경우**: 즉시 Access/Refresh Token을 발급하고 로그인을 완료합니다.
   - **활성 세션이 있을 경우**: `has_active_session: true`와 기존 세션 정보를 반환합니다 (토큰은 발급하지 않음).

### 3단계: 동시접속 선택 (충돌 시)
1. 클라이언트는 `SessionConflictModal`을 표시합니다.
2. 사용자가 **"기존 세션 종료 후 로그인"**을 선택하면:
   - 클라이언트가 `/api/v1/auth/complete-force-login`을 호출합니다.
   - 서버는 기존 세션을 모두 폐기(`revoked_yn = 'Y'`)하고 새로운 세션 및 토큰을 발급합니다.
3. 사용자가 **"취소"**를 선택하면 로그인 프로세스가 중단됩니다.

---

## 🛠️ 2. 기술 세부 사항

### 2.1. 토큰 발급 (`JWT`)
- **Access Token**: API 호출 시 Authorization 헤더에 Bearer 스킴으로 사용됩니다.
- **Session ID**: Access Token의 페이로드에는 `session_id` (실제로는 `refresh_token` 문자열)가 포함되어 있어, 요청 시마다 DB에서 세션 유효성을 체크할 수 있습니다.

### 2.2. 보안 고려 사항
- **IP 및 디바이스 기록**: 로그인 시점의 IP 주소와 User-Agent 정보를 `auth_refresh_token` 테이블에 기록하여 보안 감사 및 사용자 안내에 활용합니다.
- **폐기 로직**: 사용자가 명시적으로 로그아웃하거나, 다른 기기에서 강제 로그인을 수행할 경우 `revoked_yn` 컬럼을 통해 즉시 모든 토큰을 무효화합니다.

---

## 🖥️ 3. 프론트엔드 구현 정보

### 3.1. 로그인 페이지
- **파일**: `client/src/domains/auth/pages/LoginPage.tsx`
- 로그 상태 및 에러 메시지 처리를 담당합니다.

### 3.2. 인증 상태 관리
- **Zustand Store**: `client/src/core/store/useAuthStore.ts` (또는 유사한 경로)에서 사용자의 인증 상태와 정보를 전역으로 관리합니다.
- **Persistence**: 로그인이 성공하면 `access_token`은 `localStorage`에 저장되어 페이지 새로고침 후에도 유지됩니다.

---

## 🔍 4. FAQ

**Q: 토큰 만료 시간은 어떻게 되나요?**
A: 기본적으로 Access Token의 수명은 보안 정책에 따라 설정되며, 활동이 없을 경우 15분(`Idle Timeout`) 지나면 세션이 무효화됩니다.

**Q: 동일 브라우저에서 여러 탭을 열면 어떻게 되나요?**
A: 동일 브라우저(세션 저장소 공유)에서는 하나의 세션으로 간주됩니다. 다른 브라우저나 시크릿 모드에서 접속할 경우 새로운 세션으로 인식되어 동시접속 제어가 작동합니다.
